{"ast":null,"code":"import _inherits from \"/Users/deonnel/dev/jobjack/jobjack-ui/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/deonnel/dev/jobjack/jobjack-ui/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _classCallCheck from \"/Users/deonnel/dev/jobjack/jobjack-ui/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/deonnel/dev/jobjack/jobjack-ui/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { filter, switchMap, distinctUntilChanged, shareReplay, map } from 'rxjs/operators';\nimport * as i0 from '@angular/core';\nimport { Injectable, InjectionToken, PLATFORM_ID, Inject, Optional, APP_INITIALIZER, NgModule } from '@angular/core';\nimport { Subject, of } from 'rxjs';\nimport { isPlatformBrowser } from '@angular/common';\nvar StorageStrategies = /*#__PURE__*/(function () {\n  (function (StorageStrategies) {\n    StorageStrategies[\"Local\"] = \"local_strategy\";\n    StorageStrategies[\"Session\"] = \"session_strategy\";\n    StorageStrategies[\"InMemory\"] = \"in_memory_strategy\";\n  })(StorageStrategies || (StorageStrategies = {}));\n\n  return StorageStrategies;\n})();\n\nvar CompatHelper = /*#__PURE__*/function () {\n  function CompatHelper() {\n    _classCallCheck(this, CompatHelper);\n  }\n\n  _createClass(CompatHelper, null, [{\n    key: \"isStorageAvailable\",\n    value: function isStorageAvailable(storage) {\n      var available = true;\n\n      try {\n        if (typeof storage === 'object') {\n          storage.setItem('test-storage', 'foobar');\n          storage.removeItem('test-storage');\n        } else available = false;\n      } catch (e) {\n        available = false;\n      }\n\n      return available;\n    }\n  }]);\n\n  return CompatHelper;\n}();\n\nfunction noop() {}\n\nvar DefaultPrefix = 'ngx-webstorage';\nvar DefaultSeparator = '|';\nvar DefaultIsCaseSensitive = false;\nvar StorageKeyManager = /*#__PURE__*/(function () {\n  var StorageKeyManager = /*#__PURE__*/function () {\n    function StorageKeyManager() {\n      _classCallCheck(this, StorageKeyManager);\n    }\n\n    _createClass(StorageKeyManager, null, [{\n      key: \"normalize\",\n      value: function normalize(raw) {\n        raw = StorageKeyManager.isCaseSensitive ? raw : raw.toLowerCase();\n        return \"\".concat(StorageKeyManager.prefix).concat(StorageKeyManager.separator).concat(raw);\n      }\n    }, {\n      key: \"isNormalizedKey\",\n      value: function isNormalizedKey(key) {\n        return key.indexOf(StorageKeyManager.prefix + StorageKeyManager.separator) === 0;\n      }\n    }, {\n      key: \"setPrefix\",\n      value: function setPrefix(prefix) {\n        StorageKeyManager.prefix = prefix;\n      }\n    }, {\n      key: \"setSeparator\",\n      value: function setSeparator(separator) {\n        StorageKeyManager.separator = separator;\n      }\n    }, {\n      key: \"setCaseSensitive\",\n      value: function setCaseSensitive(enable) {\n        StorageKeyManager.isCaseSensitive = enable;\n      }\n    }, {\n      key: \"consumeConfiguration\",\n      value: function consumeConfiguration(config) {\n        if ('prefix' in config) this.setPrefix(config.prefix);\n        if ('separator' in config) this.setSeparator(config.separator);\n        if ('caseSensitive' in config) this.setCaseSensitive(config.caseSensitive);\n      }\n    }]);\n\n    return StorageKeyManager;\n  }();\n\n  StorageKeyManager.prefix = DefaultPrefix;\n  StorageKeyManager.separator = DefaultSeparator;\n  StorageKeyManager.isCaseSensitive = DefaultIsCaseSensitive;\n  return StorageKeyManager;\n})();\n\nvar SyncStorage = /*#__PURE__*/function () {\n  function SyncStorage(strategy) {\n    _classCallCheck(this, SyncStorage);\n\n    this.strategy = strategy;\n  }\n\n  _createClass(SyncStorage, [{\n    key: \"retrieve\",\n    value: function retrieve(key) {\n      var value;\n      this.strategy.get(StorageKeyManager.normalize(key)).subscribe(function (result) {\n        return value = typeof result === 'undefined' ? null : result;\n      });\n      return value;\n    }\n  }, {\n    key: \"store\",\n    value: function store(key, value) {\n      this.strategy.set(StorageKeyManager.normalize(key), value).subscribe(noop);\n      return value;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear(key) {\n      if (key !== undefined) this.strategy.del(StorageKeyManager.normalize(key)).subscribe(noop);else this.strategy.clear().subscribe(noop);\n    }\n  }, {\n    key: \"getStrategyName\",\n    value: function getStrategyName() {\n      return this.strategy.name;\n    }\n  }, {\n    key: \"observe\",\n    value: function observe(key) {\n      var _this = this;\n\n      key = StorageKeyManager.normalize(key);\n      return this.strategy.keyChanges.pipe(filter(function (changed) {\n        return changed === null || changed === key;\n      }), switchMap(function () {\n        return _this.strategy.get(key);\n      }), distinctUntilChanged(), shareReplay({\n        refCount: true,\n        bufferSize: 1\n      }));\n    }\n  }]);\n\n  return SyncStorage;\n}();\n\nvar AsyncStorage = /*#__PURE__*/function () {\n  function AsyncStorage(strategy) {\n    _classCallCheck(this, AsyncStorage);\n\n    this.strategy = strategy;\n  }\n\n  _createClass(AsyncStorage, [{\n    key: \"retrieve\",\n    value: function retrieve(key) {\n      return this.strategy.get(StorageKeyManager.normalize(key)).pipe(map(function (value) {\n        return typeof value === 'undefined' ? null : value;\n      }));\n    }\n  }, {\n    key: \"store\",\n    value: function store(key, value) {\n      return this.strategy.set(StorageKeyManager.normalize(key), value);\n    }\n  }, {\n    key: \"clear\",\n    value: function clear(key) {\n      return key !== undefined ? this.strategy.del(StorageKeyManager.normalize(key)) : this.strategy.clear();\n    }\n  }, {\n    key: \"getStrategyName\",\n    value: function getStrategyName() {\n      return this.strategy.name;\n    }\n  }, {\n    key: \"observe\",\n    value: function observe(key) {\n      var _this2 = this;\n\n      key = StorageKeyManager.normalize(key);\n      return this.strategy.keyChanges.pipe(filter(function (changed) {\n        return changed === null || changed === key;\n      }), switchMap(function () {\n        return _this2.strategy.get(key);\n      }), distinctUntilChanged(), shareReplay({\n        refCount: true,\n        bufferSize: 1\n      }));\n    }\n  }]);\n\n  return AsyncStorage;\n}();\n\nvar StrategyCacheService = /*#__PURE__*/(function () {\n  var StrategyCacheService = /*#__PURE__*/function () {\n    function StrategyCacheService() {\n      _classCallCheck(this, StrategyCacheService);\n\n      this.caches = {};\n    }\n\n    _createClass(StrategyCacheService, [{\n      key: \"get\",\n      value: function get(strategyName, key) {\n        return this.getCacheStore(strategyName)[key];\n      }\n    }, {\n      key: \"set\",\n      value: function set(strategyName, key, value) {\n        this.getCacheStore(strategyName)[key] = value;\n      }\n    }, {\n      key: \"del\",\n      value: function del(strategyName, key) {\n        delete this.getCacheStore(strategyName)[key];\n      }\n    }, {\n      key: \"clear\",\n      value: function clear(strategyName) {\n        this.caches[strategyName] = {};\n      }\n    }, {\n      key: \"getCacheStore\",\n      value: function getCacheStore(strategyName) {\n        if (strategyName in this.caches) return this.caches[strategyName];\n        return this.caches[strategyName] = {};\n      }\n    }]);\n\n    return StrategyCacheService;\n  }();\n\n  StrategyCacheService.ɵfac = function StrategyCacheService_Factory(t) {\n    return new (t || StrategyCacheService)();\n  };\n\n  StrategyCacheService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: StrategyCacheService,\n    factory: StrategyCacheService.ɵfac,\n    providedIn: 'root'\n  });\n  return StrategyCacheService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar LOCAL_STORAGE = new InjectionToken('window_local_storage');\n\nfunction getLocalStorage() {\n  return typeof window !== 'undefined' ? window.localStorage : null;\n}\n\nvar LocalStorageProvider = {\n  provide: LOCAL_STORAGE,\n  useFactory: getLocalStorage\n};\nvar SESSION_STORAGE = new InjectionToken('window_session_storage');\n\nfunction getSessionStorage() {\n  return typeof window !== 'undefined' ? window.sessionStorage : null;\n}\n\nvar SessionStorageProvider = {\n  provide: SESSION_STORAGE,\n  useFactory: getSessionStorage\n};\n\nvar BaseSyncStorageStrategy = /*#__PURE__*/function () {\n  function BaseSyncStorageStrategy(storage, cache) {\n    _classCallCheck(this, BaseSyncStorageStrategy);\n\n    this.storage = storage;\n    this.cache = cache;\n    this.keyChanges = new Subject();\n  }\n\n  _createClass(BaseSyncStorageStrategy, [{\n    key: \"isAvailable\",\n    get: function get() {\n      if (this._isAvailable === undefined) this._isAvailable = CompatHelper.isStorageAvailable(this.storage);\n      return this._isAvailable;\n    }\n  }, {\n    key: \"get\",\n    value: function get(key) {\n      var data = this.cache.get(this.name, key);\n      if (data !== undefined) return of(data);\n\n      try {\n        var item = this.storage.getItem(key);\n\n        if (item !== null) {\n          data = JSON.parse(item);\n          this.cache.set(this.name, key, data);\n        }\n      } catch (err) {\n        console.warn(err);\n      }\n\n      return of(data);\n    }\n  }, {\n    key: \"set\",\n    value: function set(key, value) {\n      var data = JSON.stringify(value);\n      this.storage.setItem(key, data);\n      this.cache.set(this.name, key, value);\n      this.keyChanges.next(key);\n      return of(value);\n    }\n  }, {\n    key: \"del\",\n    value: function del(key) {\n      this.storage.removeItem(key);\n      this.cache.del(this.name, key);\n      this.keyChanges.next(key);\n      return of(null);\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.storage.clear();\n      this.cache.clear(this.name);\n      this.keyChanges.next(null);\n      return of(null);\n    }\n  }]);\n\n  return BaseSyncStorageStrategy;\n}();\n\nvar LocalStorageStrategy = /*#__PURE__*/function (_BaseSyncStorageStrat) {\n  _inherits(LocalStorageStrategy, _BaseSyncStorageStrat);\n\n  var _super = _createSuper(LocalStorageStrategy);\n\n  function LocalStorageStrategy(storage, cache, platformId, zone) {\n    var _this3;\n\n    _classCallCheck(this, LocalStorageStrategy);\n\n    _this3 = _super.call(this, storage, cache);\n    _this3.storage = storage;\n    _this3.cache = cache;\n    _this3.platformId = platformId;\n    _this3.zone = zone;\n    _this3.name = LocalStorageStrategy.strategyName;\n    if (isPlatformBrowser(_this3.platformId)) _this3.listenExternalChanges();\n    return _this3;\n  }\n\n  _createClass(LocalStorageStrategy, [{\n    key: \"listenExternalChanges\",\n    value: function listenExternalChanges() {\n      var _this4 = this;\n\n      window.addEventListener('storage', function (event) {\n        return _this4.zone.run(function () {\n          if (event.storageArea !== _this4.storage) return;\n          var key = event.key;\n          if (key !== null) _this4.cache.del(_this4.name, event.key);else _this4.cache.clear(_this4.name);\n\n          _this4.keyChanges.next(key);\n        });\n      });\n    }\n  }]);\n\n  return LocalStorageStrategy;\n}(BaseSyncStorageStrategy);\n\nLocalStorageStrategy.strategyName = StorageStrategies.Local;\n\nLocalStorageStrategy.ɵfac = function LocalStorageStrategy_Factory(t) {\n  return new (t || LocalStorageStrategy)(i0.ɵɵinject(LOCAL_STORAGE), i0.ɵɵinject(StrategyCacheService), i0.ɵɵinject(PLATFORM_ID), i0.ɵɵinject(i0.NgZone));\n};\n\nLocalStorageStrategy.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: LocalStorageStrategy,\n  factory: LocalStorageStrategy.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar SessionStorageStrategy = /*#__PURE__*/function (_BaseSyncStorageStrat2) {\n  _inherits(SessionStorageStrategy, _BaseSyncStorageStrat2);\n\n  var _super2 = _createSuper(SessionStorageStrategy);\n\n  function SessionStorageStrategy(storage, cache, platformId, zone) {\n    var _this5;\n\n    _classCallCheck(this, SessionStorageStrategy);\n\n    _this5 = _super2.call(this, storage, cache);\n    _this5.storage = storage;\n    _this5.cache = cache;\n    _this5.platformId = platformId;\n    _this5.zone = zone;\n    _this5.name = SessionStorageStrategy.strategyName;\n    if (isPlatformBrowser(_this5.platformId)) _this5.listenExternalChanges();\n    return _this5;\n  }\n\n  _createClass(SessionStorageStrategy, [{\n    key: \"listenExternalChanges\",\n    value: function listenExternalChanges() {\n      var _this6 = this;\n\n      window.addEventListener('storage', function (event) {\n        return _this6.zone.run(function () {\n          if (event.storageArea !== _this6.storage) return;\n          var key = event.key;\n          if (event.key !== null) _this6.cache.del(_this6.name, event.key);else _this6.cache.clear(_this6.name);\n\n          _this6.keyChanges.next(key);\n        });\n      });\n    }\n  }]);\n\n  return SessionStorageStrategy;\n}(BaseSyncStorageStrategy);\n\nSessionStorageStrategy.strategyName = StorageStrategies.Session;\n\nSessionStorageStrategy.ɵfac = function SessionStorageStrategy_Factory(t) {\n  return new (t || SessionStorageStrategy)(i0.ɵɵinject(SESSION_STORAGE), i0.ɵɵinject(StrategyCacheService), i0.ɵɵinject(PLATFORM_ID), i0.ɵɵinject(i0.NgZone));\n};\n\nSessionStorageStrategy.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: SessionStorageStrategy,\n  factory: SessionStorageStrategy.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar InMemoryStorageStrategy = /*#__PURE__*/function () {\n  function InMemoryStorageStrategy(cache) {\n    _classCallCheck(this, InMemoryStorageStrategy);\n\n    this.cache = cache;\n    this.keyChanges = new Subject();\n    this.isAvailable = true;\n    this.name = InMemoryStorageStrategy.strategyName;\n  }\n\n  _createClass(InMemoryStorageStrategy, [{\n    key: \"get\",\n    value: function get(key) {\n      return of(this.cache.get(this.name, key));\n    }\n  }, {\n    key: \"set\",\n    value: function set(key, value) {\n      this.cache.set(this.name, key, value);\n      this.keyChanges.next(key);\n      return of(value);\n    }\n  }, {\n    key: \"del\",\n    value: function del(key) {\n      this.cache.del(this.name, key);\n      this.keyChanges.next(key);\n      return of(null);\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.cache.clear(this.name);\n      this.keyChanges.next(null);\n      return of(null);\n    }\n  }]);\n\n  return InMemoryStorageStrategy;\n}();\n\nInMemoryStorageStrategy.strategyName = StorageStrategies.InMemory;\n\nInMemoryStorageStrategy.ɵfac = function InMemoryStorageStrategy_Factory(t) {\n  return new (t || InMemoryStorageStrategy)(i0.ɵɵinject(StrategyCacheService));\n};\n\nInMemoryStorageStrategy.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: InMemoryStorageStrategy,\n  factory: InMemoryStorageStrategy.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar STORAGE_STRATEGIES = new InjectionToken('STORAGE_STRATEGIES');\nvar Strategies = [{\n  provide: STORAGE_STRATEGIES,\n  useClass: InMemoryStorageStrategy,\n  multi: true\n}, {\n  provide: STORAGE_STRATEGIES,\n  useClass: LocalStorageStrategy,\n  multi: true\n}, {\n  provide: STORAGE_STRATEGIES,\n  useClass: SessionStorageStrategy,\n  multi: true\n}];\nvar StorageStrategyStubName = 'stub_strategy';\n\nvar StorageStrategyStub = /*#__PURE__*/function () {\n  function StorageStrategyStub(name) {\n    _classCallCheck(this, StorageStrategyStub);\n\n    this.keyChanges = new Subject();\n    this.store = {};\n    this._available = true;\n    this.name = name || StorageStrategyStubName;\n  }\n\n  _createClass(StorageStrategyStub, [{\n    key: \"isAvailable\",\n    get: function get() {\n      return this._available;\n    }\n  }, {\n    key: \"get\",\n    value: function get(key) {\n      return of(this.store[key]);\n    }\n  }, {\n    key: \"set\",\n    value: function set(key, value) {\n      this.store[key] = value;\n      this.keyChanges.next(key);\n      return of(value);\n    }\n  }, {\n    key: \"del\",\n    value: function del(key) {\n      delete this.store[key];\n      this.keyChanges.next(key);\n      return of(null);\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.store = {};\n      this.keyChanges.next(null);\n      return of(null);\n    }\n  }]);\n\n  return StorageStrategyStub;\n}();\n\nvar StorageStub = /*#__PURE__*/function () {\n  function StorageStub() {\n    _classCallCheck(this, StorageStub);\n\n    this.store = {};\n  }\n\n  _createClass(StorageStub, [{\n    key: \"length\",\n    get: function get() {\n      return Object.keys(this.store).length;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.store = {};\n    }\n  }, {\n    key: \"getItem\",\n    value: function getItem(key) {\n      return this.store[key] || null;\n    }\n  }, {\n    key: \"key\",\n    value: function key(index) {\n      return Object.keys(this.store)[index];\n    }\n  }, {\n    key: \"removeItem\",\n    value: function removeItem(key) {\n      delete this.store[key];\n    }\n  }, {\n    key: \"setItem\",\n    value: function setItem(key, value) {\n      this.store[key] = value;\n    }\n  }]);\n\n  return StorageStub;\n}();\n\nvar InvalidStrategyError = 'invalid_strategy';\nvar StrategyIndex = /*#__PURE__*/(function () {\n  var StrategyIndex = /*#__PURE__*/function () {\n    function StrategyIndex(strategies) {\n      _classCallCheck(this, StrategyIndex);\n\n      this.strategies = strategies;\n      this.registration$ = new Subject();\n      if (!strategies) strategies = [];\n      this.strategies = strategies.reverse().map(function (strategy, index, arr) {\n        return strategy.name;\n      }).map(function (name, index, arr) {\n        return arr.indexOf(name) === index ? index : null;\n      }).filter(function (index) {\n        return index !== null;\n      }).map(function (index) {\n        return strategies[index];\n      });\n    }\n\n    _createClass(StrategyIndex, [{\n      key: \"getStrategy\",\n      value: function getStrategy(name) {\n        return StrategyIndex.get(name);\n      }\n    }, {\n      key: \"indexStrategies\",\n      value: function indexStrategies() {\n        var _this7 = this;\n\n        this.strategies.forEach(function (strategy) {\n          return _this7.register(strategy.name, strategy);\n        });\n      }\n    }, {\n      key: \"indexStrategy\",\n      value: function indexStrategy(name) {\n        var overrideIfExists = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        if (StrategyIndex.isStrategyRegistered(name) && !overrideIfExists) return StrategyIndex.get(name);\n        var strategy = this.strategies.find(function (strategy) {\n          return strategy.name === name;\n        });\n        if (!strategy) throw new Error(InvalidStrategyError);\n        this.register(name, strategy, overrideIfExists);\n        return strategy;\n      }\n    }, {\n      key: \"register\",\n      value: function register(name, strategy) {\n        var overrideIfExists = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n        if (!StrategyIndex.isStrategyRegistered(name) || overrideIfExists) {\n          StrategyIndex.set(name, strategy);\n          this.registration$.next(name);\n        }\n      }\n    }], [{\n      key: \"get\",\n      value: function get(name) {\n        if (!this.isStrategyRegistered(name)) throw Error(InvalidStrategyError);\n        var strategy = this.index[name];\n\n        if (!strategy.isAvailable) {\n          strategy = this.index[StorageStrategies.InMemory];\n        }\n\n        return strategy;\n      }\n    }, {\n      key: \"set\",\n      value: function set(name, strategy) {\n        this.index[name] = strategy;\n      }\n    }, {\n      key: \"clear\",\n      value: function clear(name) {\n        if (name !== undefined) delete this.index[name];else this.index = {};\n      }\n    }, {\n      key: \"isStrategyRegistered\",\n      value: function isStrategyRegistered(name) {\n        return name in this.index;\n      }\n    }, {\n      key: \"hasRegistredStrategies\",\n      value: function hasRegistredStrategies() {\n        return Object.keys(this.index).length > 0;\n      }\n    }]);\n\n    return StrategyIndex;\n  }();\n\n  StrategyIndex.index = {};\n\n  StrategyIndex.ɵfac = function StrategyIndex_Factory(t) {\n    return new (t || StrategyIndex)(i0.ɵɵinject(STORAGE_STRATEGIES, 8));\n  };\n\n  StrategyIndex.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: StrategyIndex,\n    factory: StrategyIndex.ɵfac,\n    providedIn: 'root'\n  });\n  return StrategyIndex;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar LocalStorageService = /*#__PURE__*/function (_SyncStorage) {\n  _inherits(LocalStorageService, _SyncStorage);\n\n  var _super3 = _createSuper(LocalStorageService);\n\n  function LocalStorageService() {\n    _classCallCheck(this, LocalStorageService);\n\n    return _super3.apply(this, arguments);\n  }\n\n  return _createClass(LocalStorageService);\n}(SyncStorage);\n\nfunction buildService$1(index) {\n  var strategy = index.indexStrategy(StorageStrategies.Local);\n  return new SyncStorage(strategy);\n}\n\nvar LocalStorageServiceProvider = {\n  provide: LocalStorageService,\n  useFactory: buildService$1,\n  deps: [StrategyIndex]\n};\n\nvar SessionStorageService = /*#__PURE__*/function (_SyncStorage2) {\n  _inherits(SessionStorageService, _SyncStorage2);\n\n  var _super4 = _createSuper(SessionStorageService);\n\n  function SessionStorageService() {\n    _classCallCheck(this, SessionStorageService);\n\n    return _super4.apply(this, arguments);\n  }\n\n  return _createClass(SessionStorageService);\n}(SyncStorage);\n\nfunction buildService(index) {\n  var strategy = index.indexStrategy(StorageStrategies.Session);\n  return new SyncStorage(strategy);\n}\n\nvar SessionStorageServiceProvider = {\n  provide: SessionStorageService,\n  useFactory: buildService,\n  deps: [StrategyIndex]\n};\n\nvar DecoratorBuilder = /*#__PURE__*/function () {\n  function DecoratorBuilder() {\n    _classCallCheck(this, DecoratorBuilder);\n  }\n\n  _createClass(DecoratorBuilder, null, [{\n    key: \"buildSyncStrategyDecorator\",\n    value: function buildSyncStrategyDecorator(strategyName, prototype, propName, key) {\n      var defaultValue = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n      var rawKey = key || propName;\n      var storageKey;\n      Object.defineProperty(prototype, propName, {\n        get: function get() {\n          var value;\n          StrategyIndex.get(strategyName).get(getKey()).subscribe(function (result) {\n            return value = result;\n          });\n          return value === undefined ? defaultValue : value;\n        },\n        set: function set(value) {\n          StrategyIndex.get(strategyName).set(getKey(), value).subscribe(noop);\n        }\n      });\n\n      function getKey() {\n        if (storageKey !== undefined) return storageKey;\n        return storageKey = StorageKeyManager.normalize(rawKey);\n      }\n    }\n  }]);\n\n  return DecoratorBuilder;\n}();\n\nfunction LocalStorage(key, defaultValue) {\n  return function (prototype, propName) {\n    DecoratorBuilder.buildSyncStrategyDecorator(StorageStrategies.Local, prototype, propName, key, defaultValue);\n  };\n}\n\nfunction SessionStorage(key, defaultValue) {\n  return function (prototype, propName) {\n    DecoratorBuilder.buildSyncStrategyDecorator(StorageStrategies.Session, prototype, propName, key, defaultValue);\n  };\n}\n\nvar Services = [LocalStorageServiceProvider, SessionStorageServiceProvider];\nvar LIB_CONFIG = new InjectionToken('ngx_webstorage_config');\n\nfunction appInit(index) {\n  index.indexStrategies();\n  return function () {\n    return StrategyIndex.index;\n  };\n}\n\nvar NgxWebstorageModule = /*#__PURE__*/(function () {\n  var NgxWebstorageModule = /*#__PURE__*/function () {\n    function NgxWebstorageModule(index, config) {\n      _classCallCheck(this, NgxWebstorageModule);\n\n      if (config) StorageKeyManager.consumeConfiguration(config);else console.error('NgxWebstorage : Possible misconfiguration (The forRoot method usage is mandatory since the 3.0.0)');\n    }\n\n    _createClass(NgxWebstorageModule, null, [{\n      key: \"forRoot\",\n      value: function forRoot() {\n        var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        return {\n          ngModule: NgxWebstorageModule,\n          providers: [{\n            provide: LIB_CONFIG,\n            useValue: config\n          }, LocalStorageProvider, SessionStorageProvider].concat(Services, Strategies, [{\n            provide: APP_INITIALIZER,\n            useFactory: appInit,\n            deps: [StrategyIndex],\n            multi: true\n          }])\n        };\n      }\n    }]);\n\n    return NgxWebstorageModule;\n  }();\n\n  NgxWebstorageModule.ɵfac = function NgxWebstorageModule_Factory(t) {\n    return new (t || NgxWebstorageModule)(i0.ɵɵinject(StrategyIndex), i0.ɵɵinject(LIB_CONFIG, 8));\n  };\n\n  NgxWebstorageModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: NgxWebstorageModule\n  });\n  NgxWebstorageModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return NgxWebstorageModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\n * Public API Surface of ngx-webstorage\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { AsyncStorage, CompatHelper, InMemoryStorageStrategy, InvalidStrategyError, LIB_CONFIG, LOCAL_STORAGE, LocalStorage, LocalStorageService, LocalStorageStrategy, NgxWebstorageModule, SESSION_STORAGE, STORAGE_STRATEGIES, SessionStorage, SessionStorageService, SessionStorageStrategy, StorageStrategies, StorageStrategyStub, StorageStrategyStubName, StorageStub, StrategyCacheService, StrategyIndex, SyncStorage, appInit }; //# sourceMappingURL=ngx-webstorage.mjs.map","map":null,"metadata":{},"sourceType":"module"}